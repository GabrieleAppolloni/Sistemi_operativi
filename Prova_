pid_t pid; 
char **file;
char **string;
int **pipes;




int main(int argc, char** argv){
 int n = argc -1;
 int n_2 ;
 int n_process;
// verifico se  N > 0
 if( argc < 5 ){
   printf("Errore nei parametri passati \n");
   return -1;
 }

 for(int i = 0 ; i<= n; i++ ){
  if(strcmp(argv[i+1],"-s") == 0){
    n_2 = i;
    break;
  }
 }
 int n_3 = (n - n_2) - 1;
 
 if(n_3 != (n_2 - 1)){
   printf("Numero di file diverso dalle stringhe");
   return -1;
 }
 pipes = malloc(sizeof(int*)*n_3);
 file = malloc(sizeof(char*)*(n_2-1));
 string = malloc(sizeof(char*)*n_3);

 if(file == NULL || string == NULL || pipe == NULL ){
  perror("malloc error ");
  exit(-1);
 }
 
 for(int k = 0; k < n_3; k++){
  string[k] = malloc(sizeof(char*));
  file[k] = malloc(sizeof(char*));
  
  file[k] = argv[k+2];
  string[k] = argv[argc- n_3 +k];
  printf("il file : %s ha la stringa %s \n",file[k], string[k]);
 }

 for(int y = 0 ; y < n_3 ; y++){
 char s[15];
 int pipe;

 snprintf(s,sizeof(s),"pipe%d",y);
 printf("%s \n",s);
retry_pipe:
  int p = mkfifo(s,0666);
  if( p < 0 ){
   if(errno == EINTR)goto retry_pipe;
   perror("errore mkfifo");
   exit(-1);
  }

retry_open_pipe:
  pipe= open(s,O_RDWR,0666);
  if(pipe < 0){
    if(errno == EINTR) goto retry_open_pipe;
    perror("errore pipe");
    exit(-1);
  }
  pipes[y] = malloc(sizeof(int));
  pipes[y] = &pipe;
 }



 n_process = n_2 -1;
 printf("%d processi \n", n_process);
 for(int j= 0 ; j < n_process; j++){
  printf("i : %d \n", j);
retry_fork:
  pid = fork();
  if(pid < 0) {
   if( errno == EINTR) goto retry_fork;
    perror("error fork: ");
    exit(-1);

  }else if(pid == 0){
  //figlio 
  int r;
  char buff[SIZE];
  int w_f;
retry_open:
   FILE* f = fopen(file[j],"w+");
   if(f == NULL ){
    if(errno == EINTR) goto retry_open;
     perror("errore fopen");
     exit(-1);
   }
   while(1){
retry_read:
    r = read(*pipes[j],buff,SIZE);
    if(r < 0){
     if(errno == EINTR) goto retry_read;
     perror("errore read pipe");
     exit(-1);
    }
    printf("ho letto %s \n", buff);
retry_fputs:
    w_f =fputs(buff,f);
    if(w_f == EOF ){
     if(errno ==  EINTR) goto retry_fputs;
     perror("errore fputs");
     exit(-1);
    }

   }
  }
 }
 // processo padre
 char buffer[SIZE];
 char* c;
 int w;
 while(1){
  c = fgets(buffer,SIZE,stdin);
  if(c == NULL){
    perror("errore fgets");
    break;
  }
  //verifico che nessun processo stia lavorando 
  for(int i = 0; i < n_3; i++){
   if(strcmp(string[i],buffer) == 0){
    
retry_write_pipe:
   w = write(*pipes[i],buffer,strlen(buffer));
   if(w < 0){
    if(errno == EINTR) goto retry_write_pipe;
     perror("errore write pipe");
     exit(-1);
   }
   break;
   }
  }
  //sincro perchÃ¨ deve attendere che il processo abbia terminato le operazioni
 }
	return 0;
}



