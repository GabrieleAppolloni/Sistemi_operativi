#ifdef Posix_compile
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <fcntl.h>
#else
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 256
#define LEN 5


typedef struct {

 int indice;


}data;

char** string;
int flag = 0;
int n; 
int turno = 0;
int* files;
pthread_mutex_t* base;

void gestore(int sig){
 flag = 1;
}

void stampa(){
 int fd;
 int num;
 int r,w;
 char buff[MAX];
 

 for(int i = 0; i < n; i++){
  fd = open(string[i+1],O_RDONLY);
  if(fd < 0){
   perror("errore open");
   break;
  }
  num = lseek(fd,SEEK_END,SEEK_SET);
  if (num < 0){
   perror("errore lseek");
   break;
  }
  num = lseek(fd,num-MAX,SEEK_SET);
  if(num < 0){
   perror("errore lseek");
   break;
  }
retry_read:
  r = read(fd,buff,LEN);
  if(r< 0){
   if(errno == EINTR) goto retry_read;
   perror("errore read");
   break;
  }
retry_write_3:
  w = write(0,buff,r);
  if(w < 0){
   if(errno == EINTR) goto retry_write_3;
   perror("errore write");
   break;
  }
 }
}




void* funzione(void* pointer){
 char buffer[MAX];
 data* curr = (data*)pointer;
 char* c;
 int w;


 while(1){
   pthread_mutex_lock(&base[curr->indice]);

   printf("inserire 5 caratteri: ");
   c =  fgets(buffer,MAX,stdin);
   if(c == NULL){
    perror("errore fgets");
    pthread_exit(NULL);
   }
   if(strlen(buffer) <= 5){
    printf("ho letto: %s \n",buffer);
retry_write:
    w = write(files[curr->indice],buffer,LEN);
    if(w < 0){
     if(errno == EINTR) goto retry_write;
     perror("write error");
     pthread_exit(NULL);
    }
   }else{
 
    printf("stringa maggiore di 5 sarÃ  troncata \n");
retry_write_2:
    w = write(files[curr->indice],buffer,LEN);
    if(w < 0){
     if(errno == EINTR) goto retry_write_2;
     perror("write error");
     pthread_exit(NULL);
    }

   }
  fflush(stdout);
  printf("il mio indice: %d \n",curr->indice);
  turno= (turno + 1) % n;
  pthread_mutex_unlock(&base[turno]);
 }


 pthread_exit(NULL);

}




int main(int argc, char** argv){

 n = argc -1;
pthread_t thread[n];
int c_thread;
data d_thread[n];
pthread_mutex_t mutex[n];
int c_mutex;
string = argv;

 if(n < 1){
  printf("errore numero dei file non valido \n");
  return -1;
 }
 files = malloc(sizeof(int)*n);

 if(files == NULL){
  perror("errore malloc");
  return -1;
 }

 for( int i = 0; i < n; i++){
  files[i] = open(argv[i+1],O_CREAT|O_WRONLY,0666);
  if( files[i] < 0){
   perror("errore open");
   return -1;
  }
 }


 for(int k =0 ; k <n ; k++){
  c_mutex = pthread_mutex_init(&mutex[k],NULL);
  if(c_mutex < 0){
   perror("errore mutex_init");
   return -1;
  }
 }

 for(int y = 1; y < n; y++){
  c_mutex = pthread_mutex_lock(&mutex[y]);
  if(c_mutex < 0){
   perror("errore lock mutex");
   return -1;
  }
 }

 base = mutex;

 for(int j = 0; j < n; j++){
  d_thread[j].indice = j;
  c_thread = pthread_create(&thread[j],NULL,funzione,(void*)&d_thread[j]);
  if( c_thread < 0){
   perror("errore pthread_create");
   return -1;
  }
 }
 
 
 signal(SIGINT,gestore);
 
 while(1){
  if(flag != 0){
   flag = 0;
  }
  stampa();
 }

	return 0;
}
